//! Exploit Modules
//!
//! Remote code execution, privilege escalation, web exploits

pub mod http;
pub mod ssh;
pub mod smb;
pub mod local;

use crate::{ModuleInfo, ModuleOption, Target, Result, Error};
use std::collections::HashMap;

/// Trait for exploit modules
pub trait ExploitModule: Send + Sync {
    /// Module metadata
    fn info(&self) -> ModuleInfo;

    /// Available options
    fn options(&self) -> Vec<ModuleOption>;

    /// Set option value
    fn set_option(&mut self, name: &str, value: &str) -> Result<()>;

    /// Check if target is vulnerable (non-destructive)
    fn check(&self, target: &Target) -> Result<CheckResult>;

    /// Run the exploit
    fn exploit(&self, target: &Target) -> Result<ExploitResult>;

    /// Get required payload type
    fn payload_type(&self) -> Option<&str> {
        None
    }
}

#[derive(Debug, Clone)]
pub enum CheckResult {
    Vulnerable(String),
    NotVulnerable(String),
    Unknown(String),
    Error(String),
}

#[derive(Debug, Clone)]
pub struct ExploitResult {
    pub success: bool,
    pub session_id: Option<String>,
    pub message: String,
    pub data: HashMap<String, String>,
}

impl ExploitResult {
    pub fn success(message: &str) -> Self {
        Self {
            success: true,
            session_id: None,
            message: message.to_string(),
            data: HashMap::new(),
        }
    }

    pub fn with_session(message: &str, session_id: &str) -> Self {
        Self {
            success: true,
            session_id: Some(session_id.to_string()),
            message: message.to_string(),
            data: HashMap::new(),
        }
    }

    pub fn failure(message: &str) -> Self {
        Self {
            success: false,
            session_id: None,
            message: message.to_string(),
            data: HashMap::new(),
        }
    }
}

/// Generic exploit struct
pub struct Exploit {
    pub info: ModuleInfo,
    pub options: HashMap<String, ModuleOption>,
    pub check_fn: Option<Box<dyn Fn(&Target) -> Result<CheckResult> + Send + Sync>>,
    pub exploit_fn: Option<Box<dyn Fn(&Target, &HashMap<String, String>) -> Result<ExploitResult> + Send + Sync>>,
}

impl Exploit {
    pub fn new(info: ModuleInfo) -> Self {
        Self {
            info,
            options: HashMap::new(),
            check_fn: None,
            exploit_fn: None,
        }
    }

    pub fn add_option(&mut self, opt: ModuleOption) {
        self.options.insert(opt.name.clone(), opt);
    }

    pub fn get_option(&self, name: &str) -> Option<String> {
        self.options.get(name).and_then(|o| o.current.clone())
    }
}
